<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
function thenPromise(PromiseRelase, x, resolve, reject){
    if(PromiseRelase === x){
        return reject(TypeError('Chaining cycle detected for promise'));
    }
    let repeat;
    if(x !== null && (typeof x === 'object' || typeof x === 'function')){
        try {
            let then = x.then;
            if(typeof then === 'function'){
                
            }
        } catch (error) {
            
        }
    }
}
class Promise{
    constructor(fn){
        this.state = 'pending'; //  成功的状态值
        this.value = null; //  成功的值
        this.err = null; //  失败的原因
        this.onFulfilledCallbacks = [] //  存放then成功的数组
        this.onRejectedCallbacks = [] //  存放this失败的数组
        let resolve = value => { // 成功的回调
            if(this.state == 'pending'){ //  等待的状态下赋值并且执行成功数组的回调
                this.value = value
                this.state = 'fulfilled';
                this.onFulfilledCallbacks.forEach(fn => fn())
            }
        }
        let reject = err => { //  与resolve同理
            if(this.state == 'pending'){
                this.err = err
                this.state = 'rejected'
                this.onRejectedCallbacks.forEach(fn => fn())
            }
        }


        try {
            fn(resolve, reject);
        } catch (error) {
            reject(error)
        }
    }
    

    then(onFulfilled, onRejected){
        let PromiseRelase = new Promise( (resolve, reject) => {
            if(this.state == 'fulfilled'){
                var x = onFulfilled(this.value)
                thenPromise(PromiseRelase, x, resolve, reject)
            }
            if(this.state == 'reject'){
                var x = onRejected(this.err)
                thenPromise(PromiseRelase, x, resolve, reject)
            }

            
            if(this.state == 'pending'){
                this.onFulfilledCallbacks.push(()=>{
                    var x = onFulfilled(this.value)
                    thenPromise(PromiseRelase, x, resolve, reject)
                })
                this.onRejectedCallbacks.push(()=>{
                    var x = onRejected(this.err)
                    thenPromise(PromiseRelase, x, resolve, reject)
                })
            }
        })
    }
}

var pro = new Promise(rev  => {
    rev(123)
}).then(res => {
    return new Promise(res => {
        res(333)
    })
})

// v8官网实现promise：https://chromium.googlesource.com/v8/v8/+/3.29.45/src/promise.js?autodive=0/
</script>
</html>
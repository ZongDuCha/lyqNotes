### `pop`  `shift`  `push`  `unshift`  `reverse`  `sort`  `splice`  `copyWithin`  `fill` 这些都是会改变自身的值的数组方法

`pop 删除数组的最后一个元素`
有意思的是,pop的设计是根据长度进行删除的，也就是说如果在对象中声明了length的长度，也可以删除？

```javascript
var obj = {1:'javascrip',2:'css',3:'vue',length:4}
Array.prototype.pop.call(obj)
console.log(obj)

// {1: "javascrip", 2: "css", length: 3}

如果length为0，将无法删除
var obj = {1:'javascrip',2:'css',3:'vue',length:0}
Array.prototype.pop.call(obj)
console.log(obj)

//{1: "javascrip", 2: "css", 3: "vue", length: 0}
```

`shift 删除数组的第一个元素`
同样和pop类似，根据长度删除

```javascript
var obj = {1:'javascrip',2:'css',3:'vue',length:4}
Array.prototype.shift.call(obj)
console.log(obj)

// {0: "javascrip", 1: "css", 2: "vue", length: 3}

如果length为0，也同样无法删除
var obj = {1:'javascrip',2:'css',3:'vue',length:0}
Array.prototype.shift.call(obj)
console.log(obj)

//{1: "javascrip", 2: "css", 3: "vue", length: 0}
```


`push 在数组的末尾添加一个或多个元素 并且返回新的数组长度`
同样是根据长度添加元素，那么可以在指定位置上添加元素？

```javascript
var obj = {1:'javascrip',2:'css',3:'vue',length:4}
Array.prototype.push.call(obj,'jq')
console.log(obj)

// {1: "javascrip", 2: "css", 3: "vue", 4: "jq", length: 5}

var obj = {1:'javascrip',2:'css',3:'vue',length:3}
Array.prototype.push.call(obj,'jq')
console.log(obj)

// {1: "javascrip", 2: "css", 3: "jq", length: 4}
只是在指定位置上替换元素

用applay 可实现合并数组
var obj = [1] ; var obj1 = [2]
var obj3 = Array.prototype.push.apply(obj,obj1)
console.log(obj)
```

`unshift 在数组开头添加一个或多个元素，并且返回新的数组长度`
同样可以指定length位置上添加元素，如果使用Array.prorotype.unshift.call(),那么会替换掉第一个原色
但是如果length为0，那么就会被解释器认为数组长度为0，会从对象的下标0开始插入，相应的位置属性会被替换掉

```javascript
var obj = {1:'javascrip',2:'css',3:'vue',length:4}
Array.prototype.unshift.apply(obj,['w'])
console.log(obj)

// {0: "w", 2: "javascrip", 3: "css", 4: "vue", length: 5}
// 替换掉第一个元素

var obj = {1:'javascrip',2:'css',3:'vue',length:0}
Array.prototype.unshift.apply(obj,['w'])
console.log(obj)

// {0: "w", 1: "javascrip", 2: "css", 3: "vue", length: 1}
// 在开头上添加一个元素，实现正常的unshift
```

`reverse 颠倒数组元素的位置 返回使用该函数的引用`
同样可以Array.prorotype.unshift.call()，颠倒的顺序只在length的范围内

```javascript
var obj = {1:'javascrip',2:'css',3:'vue',length:2}
Array.prototype.reverse.call(obj)
console.log(obj)

// {0: "javascrip", 2: "css", 3: "vue", length: 2}

如果length为0，相当于没有执行
```

`sort 对数组的元素排序 并返回这个数组`
`arr.sort([comparefn])`
sort可以指定一个带返回的comparefn函数，如果省略掉，数组元素就会按照各自转换为Unicode（万国码）位点顺序排序,比如javascript比css靠前，数字排序比较的时候，也会先转换成字符串的Unicode进行排序,比如：'25'比'8'靠前

```javascript
var obj = ['javascript','css','vue']
Array.prototype.sort.call(obj)
console.log(obj)

//  ["css", "javascript", "vue"]

var obj = ['1','21','13','21']
Array.prototype.sort.call(obj)
console.log(obj)

//  ["1", "13", "21", "21"]
```

如果指定了带返回的comparefn函数，数组将按照该函数的返回值来排序，若a和b是两个将要比较的元素

```javascript
comparefn(a,b) > 0 // 如果b比a大，那么排在前面
comparefn(a,b) < 0 // 如果a比b大，那么排在前面
comparefn(a,b) = 0 // 相对位置不变

// 也可以在comparefn内直接返回比较后的值

comparefn(a,b){
    return a > b // 数字比较可以用： a-b
}

comparefn(a,b){
    return a < b // 数字比较可以用 b - a 
}

comparefn(a,b){
    return a = b
}
```

如果数组元素为非ASCII字符的字符串（如包含类似 e、é、è、a、ä 或中文等非英文字符的字符串），则需要使用String.localCompare

```javascript
var arr = ['互','联','网','改','变','世','界'];
arr.sort(function (a,b){
    return a.localeCompare(b)
})
console.log(arr)

// (7) ["世", "互", "变", "改", "界", "网", "联"]
```

sort 也同样适用Array.prorotype.unshift.call()

```javascript
var obj = {0:'互',1:'联',2:'网',3:'改',4:'变',5:'世',6:'界',length:4};
Array.prototype.sort.call(obj,function(a, b){
  return a.localeCompare(b);
});
console.log(obj);

// {0: "互", 1: "改", 2: "网", 3: "联", 4: "变", 5: "世", 6: "界", length: 4}
```

### Chrome的不同
ECMAscript规范中并未规定具体的sort算法，这就势必导致各个浏览器不尽相同的sort算法，下面是Chrome下使用sort的表现：

```javascript
arr = [{s:'1',a:'a'},{s:'1',a:'b'},{s:'1',a:"c"},{s:'1',a:'d'},{s:'1',a:'e'},{s:'1',a:'f'},{s:'1',a:'g'},{s:'1',a:'h'},{s:'q',a:'i'},{s:'1',a:'j'},{s:'1',a:'k'}]
arr.sort(function(v1,v2){
	return v1.s-v2.s
})
for(let i in arr){
	console.log(arr[i].a)
}

// f a c d e b g h i j k
```

由于s值相等，arr数组排序前后应该不变，然而Chrome输出的却不同，而其他浏览器(如IE 或 Firefox) 表现正常。
当排序的数组长度超过10条时，会调用另一种排序方法（快速排序）；而10条及以下采用的是插入排序，所以在使用sort排序时改变排序的返回值即可，应该这么写才能将结果准确输出：

```javascript
arr = [{s:'1',a:'a'},{s:'1',a:'b'},{s:'1',a:"c"},{s:'1',a:'d'},{s:'1',a:'e'},{s:'1',a:'f'},{s:'1',a:'g'},{s:'1',a:'h'},{s:'q',a:'i'},{s:'1',a:'j'},{s:'1',a:'k'}]
arr.forEach(function(v,k){
	v.__index = k
})
arr.sort(function(v1,v2){
	return v1.s-v2.s || v1.__index - v2.__index
})
for(let i in arr){
	console.log(arr[i].a)
}

// a b c d e f g h i j k
```

而且使用数组的sort的排序方法需要注意的是，各浏览器的针对sort方法的内部算法实现不同，排序函数尽量值返回-1，0，1三种不同的值，不要尝试返回true和false等其它数值，因为可能导致不可靠的排序结果

|睡过   |哈哈  |请问|
|------ |-----|----|
|123    |123  |123 |


### 不同的浏览器及脚本引擎
|Browser Name	|ECMAScript Engine|
|-----|-----|
|Internet Explorer 6 - 8	|JScript|
|Internet Explorer 9 - 10	|Chakra|
|Firefox	|SpiderMonkey, IonMonkey, TraceMonkey|
|Chrome	|V8|
|Safair	|JavaScriptCore(SquirrelFish Extreme)|
|Opera	|Carakan|


分析以下代码，预期将数组元素进行升序排序：

```javascript
var array = [7, 6, 5, 4, 3, 2, 1, 0, 8, 9];
var comparefn = function (x, y) {
  return x > y;
};
array.sort(comparefn);
```

代码中，comparefn 函数返回值为 bool 类型，并非为规范规定的 -1、0、1 值。那么执行此代码，各 JS 脚本引擎实现情况如何？

|	|输出结果|	是否符合预期|
|---|------|----------|
|JScript	|[2, 3, 5, 1, 4, 6, 7, 0, 8, 9]	|否|
|Carakan	|[0, 1, 3, 8, 2, 4, 9, 5, 6, 7]	|否|
|Chakra & JavaScriptCore	|[7, 6, 5, 4, 3, 2, 1, 0, 8, 9]	|否|
|SpiderMonkey	|[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]	|是|
|V8	|[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]	|是|

根据表中数据可见，当数组内元素个数小于等于 10 时，现象如下：
- JScript & Carakan 排序结果有误
- Chakra & JavaScriptCore 看起来没有进行排序
- SpiderMonkey 返回了预期的正确结果
- V8 暂时看起来排序正确

将数组元素扩大至 11 位，现象如下：
```javascript
var array = [7, 6, 5, 4, 3, 2, 1, 0, 10, 9, 8];
var comparefn = function (x, y) {
  return x > y;
};
array.sort(comparefn);
```

|JavaScript引擎	|输出结果	|是否符合预期|
|----|----|----|
|JScript	|[2, 3, 5, 1, 4, 6, 7, 0, 8, 9, 10]	|否|
|Carakan	|[0, 1, 3, 8, 2, 4, 9, 5, 10, 6, 7]	|否|
|Chakra & JavaScriptCore	|[7, 6, 5, 4, 3, 2, 1, 0, 10, 8, 9]	|否|
|IonMonkey	|[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]	|是|
|V8	|[5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]	|否|

根据表中数据可见，当数组内元素个数大于 10 时：

- JScript & Carakan 排序结果有误
- Chakra & JavaScriptCore 看起来没有进行排序
- SpiderMonkey 返回了预期的正确结果
- V8 排序结果由正确转为不正确

(感觉sort稍微复杂了点，主要还是ECMAscript规范中并未规定sort算法，所以导致每个浏览器的有不同的算法，不同的结果)


### splice 新元素替换旧元素的方式修改数组，特别适用于需要维持原数组引用时，就地删除或者新增元素，splice最适合

`arr.splice(start,deleteCount[, item1[, item2[, …]]])`
`start` 指定从哪一位开始修改内容，如果超过了数组的长度，则从数组的末尾开始修改内容；
如果是负数，则其指定的索引位置等同于length+start（length为数组的长度），表示从数组的末尾开始的第-start位开始；


`deleteCount` 指定要删除的元素个数,若等于0,则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素和，则start及之后的元素都被删除。

`itemN`  指定替换的删除后的元素或新增元素,如果忽略掉，则该方法只会删除元素

`返回值` 由原数组中被删除元素组成的数组，如果没有删除，则返回一个数组，比如：
```javascript
var array = ["apple","boy"];
var splices = array.splice(1,1);
console.log(array); // ["apple"]
console.log(splices); // ["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素

array = ["apple","boy"];
splices = array.splice(2,1,"cat");
console.log(array); // ["apple", "boy", "cat"]
console.log(splices); // [], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为

array = ["apple","boy"];
splices = array.splice(-2,1,"cat");
console.log(array); // ["cat", "boy"]
console.log(splices); // ["apple"], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素

array = ["apple","boy"];
splices = array.splice(-3,1,"cat");
console.log(array); // ["cat", "boy"]
console.log(splices); // ["apple"], 可见即使-start超出数组长度,数组默认从首位开始删除

array = ["apple","boy"];
splices = array.splice(0,3,"cat");
console.log(array); // ["cat"]
console.log(splices); // ["apple", "boy"], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除
```

同样，splice可以用在Array.prototype.splice.call()上

```javascript
arr = {1:'javascript',2:'css',3:"jq",length:'2'}
Array.prototype.splice.call(arr,1,1)
console.log(arr)
// {2: "css", 3: "jq", length: 1}
```

如果需要删除数组中一个已存在的元素，可参考如下：

```javascript
var array = ['a','b','c'];
array.splice(array.indexOf('b'),1);
```


### copyWihtnin 基于ECMAScript 2015 (es6)规范，用于数组内元素之间的替换，即替换的元素和被替换的元素均是数组内的元素。（更简单的来说就是将一个数组内的元素替换到 别的位置及属性）

语法：arr.copyWithin(target, start[, end = this.length])

```javascript
arr.copyWithin(target)

arr.copyWithin(target, start)

arr.copyWithin(target, start, end)

arr.copyWithin(目标索引, [源开始索引], [结束源索引])
```

`target`
0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。
如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将   被修改以符合 arr.length。

`start`
0 为基底的索引，开始复制元素的起始位置。如果是负数，start 则其指定的索引位置等同于length+start,将从末尾开始计算。
如果 start 被忽略，copyWithin 将会从0开始复制。

`end`
0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。
如果 end 被忽略，copyWithin 将会复制到 arr.length。（但是我觉得因为换成：如果 end 被忽略，那么end默认为数组的索引长度，）

`copyWithin`方法不要求其this值必须是一个数组对象；除此之外，copyWithin是一个可变方法，它可以改变this对象本身，并且返回它，而不仅仅是它的拷贝。

MDN的例子很好的说明了：

```javascript
[1, 2, 3, 4, 5].copyWithin(-2);
// [1, 2, 3, 1, 2]

[1, 2, 3, 4, 5].copyWithin(0, 3);
// [4, 5, 3, 4, 5]

[1, 2, 3, 4, 5].copyWithin(0, 3, 4);
// [4, 2, 3, 4, 5]

[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);
// [1, 2, 3, 3, 4]

[].copyWithin.call({length: 5, 3: 1}, 0, 3);
// {0: 1, 3: 1, length: 5}

var i32a = new Int32Array([1, 2, 3, 4, 5]);

i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
```

不支持copyWithin,可以使用polyfill
```javascript
if (!Array.prototype.copyWithin) {
  Array.prototype.copyWithin = function(target, start/*, end*/) {
    // Steps 1-2.
    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    var O = Object(this);

    // Steps 3-5.
    var len = O.length >>> 0;

    // Steps 6-8.
    var relativeTarget = target >> 0;

    var to = relativeTarget < 0 ?
      Math.max(len + relativeTarget, 0) :
      Math.min(relativeTarget, len);

    // Steps 9-11.
    var relativeStart = start >> 0;

    var from = relativeStart < 0 ?
      Math.max(len + relativeStart, 0) :
      Math.min(relativeStart, len);

    // Steps 12-14.
    var end = arguments[2];
    var relativeEnd = end === undefined ? len : end >> 0;

    var final = relativeEnd < 0 ?
      Math.max(len + relativeEnd, 0) :
      Math.min(relativeEnd, len);

    // Step 15.
    var count = Math.min(final - from, len - to);

    // Steps 16-17.
    var direction = 1;

    if (from < to && to < (from + count)) {
      direction = -1;
      from += count - 1;
      to += count - 1;
    }

    // Step 18.
    while (count > 0) {
      if (from in O) {
        O[to] = O[from];
      } else {
        delete O[to];
      }

      from += direction;
      to += direction;
      count--;
    }

    // Step 19.
    return O;
  };
}
```

copyWithin也同样可以用Array.prototype.copyWithin.call()

```javascript
var o = {0:1, 1:2, 2:3, 3:4, 4:5,length:5}
Array.prototype.copyWithin.call(o,0,3);

// {0: 4, 1: 5, 2: 3, 3: 4, 4: 5, length: 5}
```

### fill 用一个固定值替换数组内从起始索引到终止索引直接的全部元素

`arr.fill(value, start, end)` 
value替换数组元素的值
start起始索引，默认为0，如果是个负数，则开始索引为length+start
end 终止索引，默认为数组索引的长度，如果是个负数，则终止索引为length+end

```javascript
[1, 2, 3].fill(4)            // [4, 4, 4]
[1, 2, 3].fill(4, 1)         // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2)      // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1)      // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2)    // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]
Array(3).fill(4);            // [4, 4, 4]
[].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}
```
不支持fill可以使用polyfill
```javascript
if (!Array.prototype.fill) {
  Object.defineProperty(Array.prototype, 'fill', {
    value: function(value) {

      // Steps 1-2.
      if (this == null) {
        throw new TypeError('this is null or not defined');
      }

      var O = Object(this);

      // Steps 3-5.
      var len = O.length >>> 0;

      // Steps 6-7.
      var start = arguments[1];
      var relativeStart = start >> 0;

      // Step 8.
      var k = relativeStart < 0 ?
        Math.max(len + relativeStart, 0) :
        Math.min(relativeStart, len);

      // Steps 9-10.
      var end = arguments[2];
      var relativeEnd = end === undefined ?
        len : end >> 0;

      // Step 11.
      var final = relativeEnd < 0 ?
        Math.max(len + relativeEnd, 0) :
        Math.min(relativeEnd, len);

      // Step 12.
      while (k < final) {
        O[k] = value;
        k++;
      }

      // Step 13.
      return O;
    }
  });
}
```
`在MDN上有一句：fill 方法故意被设计成通用方法, 它需要this值是个对象，类数组对象调用会报错`

但是发现 fill 也同样适用于Array.prototype.fill.call()

```javascript
var o = {0:1, 1:2, 2:3, 3:4, 4:5,length:5}
var o2 = Array.prototype.fill.call(o,10,0,2);

// {0: 10, 1: 10, 2: 3, 3: 4, 4: 5, length: 5}
```

与copyWithin不同的是，copyWithin是只能数组之间替换元素
而fill是指定一个固定值然后替换掉数组相应的数组索引


### `concat`  `join`  `slice`  `toString`  `toLocateString`  `indexOf`  `lastIndexOf`  都是不会改变自身的数组方法


### concat 将传入的数组或元素与原数组合并,组成新的数组并返回

语法：arr.concat(value1, value2, …, valueN)

```javascript
var arr = [1,2]
var arr2 = arr.concat([3,4],[5,6])
console.log(arr2)

// [1, 2, 3, 4, 5, 6]
```

若concat不传入参数，那么将基于原数组浅复制生成一个一样的新数组（指向新的地址空间）
```javascript
var arr = [1,2]
var arr2 = arr.concat()
arr2.push(1)
console.log(arr,arr2)

// [1, 2] [1, 2, 1]
```
<!-- more -->

同样，concat也可以用Array.prototype.concat.call(),但是结果却不是我们想要的

```javascript
var arr = {1:'q',2:'w',length:2}
var arr2 = Array.prototype.concat.call(arr,'q',{3:'e',length:1})
console.log(arr2)

// 0:{1: "q", 2: "w", length: 2}
// 1:"q"
// 2:{3: "e", length: 1}
```
类数组对象合并后返回的是依然是数组，并不是我们想要的结果


### join 将数组中的所有元素连接成一个字符串

语法：arr.join([separator = ‘,’]) separator可选，缺省默认为逗号。

```javascript
var arr = ['js','css','jq']
var arr2 = arr.join()
var arr3 = arr.join('-')
var arr4 = arr.join(' 1 ')
console.log(arr2,arr3,arr4)

// js,css,jq js-css-jq js 1 css 1 jq
```

同样，join也可以用Array.prototype.join.call()

```javascript
var arr = ['js','css','jq']
var arr2 = Array.prototype.join.call(arr,'-')
console.log(arr2)

// js-css-jq
```


### slice 将数组的一部分浅复制存入新的数组对象里,并且返回这个数组对象

语法：arr.slice([start[, end]])

start 从数组的索引开始提取元素，如果传入的参数为负数，则表示从原数组中的末尾倒数第几个元素，如果省略，那么slice的索引为0开始。
end 结束数组的索引位置，并且提取start到end的索引（不包括end）如果被省略或者end大于数组的索引长度，slice会一直提取到原数组的末尾（相当于从start到数组的最后一个元素）

按照MDN的对slice的描述：

```
slice 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：

如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。

对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。

如果向两个数组任一中添加了新元素，则另一个不会受到影响。
```

```javascript
var arr = ['js','css','jq']
var arr2 = arr.slice(0,1)
arr2.push('vue')
console.log(arr,arr2)
// ["js", "css", "jq"] (2) ["js", "vue"]
```

slice 也适用于Array.prototype.slice.call()

```javascript
var arr = [1,2,3]
var arr2 = Array.prototype.slice.call(arr,0,1)
console.log(arr2)
// [1]
```

另外不支持的可以用polyfill

```javascript
(function () {
    'use strict';
    var _slice = Array.prototype.slice;

    try {
        // Can't be used with DOM elements in IE < 9
        _slice.call(document.documentElement);
    } catch (e) { // Fails in IE < 9
        // This will work for genuine arrays, array-like objects,
        // NamedNodeMap (attributes, entities, notations),
        // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
        // and will not fail on other DOM objects (as do DOM elements in IE < 9)
        Array.prototype.slice = function (begin, end) {
            // IE < 9 gets unhappy with an undefined end argument
            end = (typeof end !== 'undefined') ? end : this.length;

            // For native Array objects, we use the native slice function
            if (Object.prototype.toString.call(this) === '[object Array]'){
                return _slice.call(this, begin, end);
            }
           
            // For array like object we handle it ourselves.
            var i, cloned = [],
                size, len = this.length;
           
            // Handle negative value for "begin"
            var start = begin || 0;
            start = (start >= 0) ? start: len + start;
           
            // Handle negative value for "end"
            var upTo = (end) ? end : len;
            if (end < 0) {
                upTo = len + end;
            }
           
            // Actual expected size of the slice
            size = upTo - start;
           
            if (size > 0) {
                cloned = new Array(size);
                if (this.charAt) {
                    for (i = 0; i < size; i++) {
                        cloned[i] = this.charAt(start + i);
                    }
                } else {
                    for (i = 0; i < size; i++) {
                        cloned[i] = this[start + i];
                    }
                }
            }
           
            return cloned;
        };
    }
}());
```

### toString 返回数组的字符串形式，该字符串由数组中的每个元素的toString()返回值经调用join()方法连接（由逗号隔开）组成。（相当于toString就是用arr.join()实现的）

```javascript
var arr = [1,2,3]
var arr2 = arr.toString()
console.log(arr2)

// 1,2,3
```

当数组直接和字符串做连接操作时，会自动调用toString方法
```js
[1,2,3,4] + [,5]

// 1,2,3,4,5

var arr = {1:'q',2:'w',3:'e',length:4}
var arr2 = Array.prototype.toString.call(arr)
console.log(arr2)
// [object Object]
```

根据ES5语义，toString() 方法是通用的，可被用于任何对象。
如果对象有一个join() 方法，将会被调用，其返回值将被返回，没有则调用Object.prototype.toString()，为此，我们给o对象添加一个join方法。如下：

```js
var o = {
  0:'Jan', 
  1:'Feb', 
  2:'Mar', 
  length:3, 
  join:function(){
    return Array.prototype.join.call(this);
  }
};
console.log(Array.prototype.toString.call(o));
```

### <a href="#toLocalString" name="toLocalString">toLocalString</a> 类似toString的变形，该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。

数组不同的元素将调用各自的toLocalString方法

- Object: Object.prototype.toLocalString
- Number: Number.prototype.toLocalString
- Date : Date.prototype.toLocalString


```js
var o = {
  0:123, 
  1:'abc', 
  2:new Date(), 
  length:3, 
  join:function(){
    return Array.prototype.join.call(this);
  }
};
console.log(Array.prototype.toLocaleString.call(o))
// 123,abc,2018/1/24 下午4:13:45
```

### indexOf 查找元素在数组中第一次出现的索引位置，如果没有，则返回-1

语法：arr.indexOf(element, fromIndex=0)

element 需要查找的元素

fromIndex 为开始查找的位置，缺省默认为0，如果超出数组的长度则返回-1。
如果为负值，假设数组长度为length，则从数组的第length+fromIndex项开始往末尾查找，如果length+fromIndex<0则整个数组都会被查找。

indexOf使用严格相等（即===去匹配数组中的元素）


```js
var array = ['abc', 'def', 'ghi','123'];
console.log(array.indexOf('def')); // 1
console.log(array.indexOf('def',-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1
console.log(array.indexOf('def',-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1
console.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串'123'
```

同样可以用Array.prototype.indexOf.call()

```js
var o = {0:'abc', 1:'def', 2:'ghi', length:3};
console.log(Array.prototype.indexOf.call(o,'ghi',-4));

// 2
```

如果不支持，可以用polyfill
```js
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {
    var k;

    // 1. Let O be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = +fromIndex || 0;

    if (Math.abs(n) === Infinity) {
      n = 0;
    }

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      if (k in O && O[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}
```



### lastIndexOf indexOf的逆向查找，即从数组的末尾处一直到数组的开头开始查找，查找元素最后一次出现时的索引位置，如果没有则返回-1.

语法：arr.lastIndexOf(element, fromIndex=length-1)

element 需要查找的元素

fromIndex 开始查找的位置，缺省默认为length-1，如果超过数组长度，犹豫是逆向查找，则查找整个数组，如果为负值，则从数组的第length+fromIndex项往数组开头开始查找，如果length|fromIndex<0数组则不会被查找。（与indexOf相反）

同indexOf一样，lastIndexOf也是严格匹配数组元素


```js
var arr = [1,2,3,4,5,6,7,8]
var arr2 = arr.lastIndexOf(6)
console.log(arr2)
// 5

var arr = [1,2,3,6,6,5,7,8]
var arr2 = arr.lastIndexOf(6)
console.log(arr2)
// 4

var arr = [1,2,3,6,6,6,7,8]
var arr2 = arr.lastIndexOf(6)
console.log(arr2)
// 5

var o = {0:'abc', 1:'def', 2:'ghi', length:3};
console.log(Array.prototype.lastIndexOf.call(o,'ghi'));

// 2
```

如果不支持，可以用polyfill

```js
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var n, k,
      t = Object(this),
      len = t.length >>> 0;
    if (len === 0) {
      return -1;
    }

    n = len - 1;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n != n) {
        n = 0;
      }
      else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    for (k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}
```



### includes(ES7) 基于ECMAScript 2016(es7)规范，他用于查找数组中是否包含某个指定的值，如果是则返回true，否则返回false

语法：arr.includes(element, fromIndex=0)

element 查找的元素

fromIndex 数组索引开始的位置,缺省为0，他是正向查找，即从索引处往数组末尾开始查找。

```js
var arr = [-0,1,2,3,4,5]
var arr2 = arr.includes(4)
var arr3 = arr.includes(-4)
var arr4 = arr.includes(2,1)
var arr5 = arr.includes(+0)
console.log(arr2,arr3,arr4,arr5)

// true,false,true,true
```

以上includes 忽略了-0和+0的区别，因为JavaScript一直以来都是不区分 -0 和 +0 的。但是只有0才不区分而已。

includes 与 indexOf 相似,但是又有一些区别。
一、index 返回的是数值型，而include返回的是布尔值,在某些时候include更好使用
```js
var ary = [1];

if (ary.indexOf(1) !== -1) {

    console.log("数组存在1")

}

if (ary.includes(1)) {

    console.log("数组存在1")

}
```

二、如果数组中有NaN，你又正好需要判断数组中是否有NaN的存在，indexOf是无法判断的，而includes却是可以的
```js
var ary1 = [NaN];

console.log(ary1.indexOf(NaN))//-1

console.log(ary1.includes(NaN))//true
```

三、当数组中有空的值时候，includeOf会认为空的值是undefined,而indexOf认为是稀疏数组，省略掉的值是不存在的
```js
var ary1 = new Array(3);

console.log(ary1.indexOf(undefined));//-1

console.log(ary1.includes(undefined))//true
```


同样适用Array.prototype.includes.call()
```js
var o = {0:'a', 1:'b', 2:'c', length:3};
var bool = Array.prototype.includes.call(o, 'a');
console.log(bool); 

// true
```

polyfill

```js
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function(searchElement, fromIndex) {

      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      //  6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      function sameValueZero(x, y) {
        return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
      }

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        // c. Increase k by 1. 
        k++;
      }

      // 8. Return false
      return false;
    }
  });
}
```


### toSource（非标准） 返回数组的源代码

```js
var array = ['a', 'b', 'c'];
console.log(array.toSource()); // ["a", "b", "c"]

// Array.prototype.toSource.call()
var o = {0:'a', 1:'b', 2:'c', length:3};
console.log(Array.prototype.toSource.call(o));

// // ["a","b","c"]
```

### forEach  every  some  filter  map  reduce  reduceRight以及es6新增的entries  find  findIndex keys  values 都是基于es6，不会改变自身的办法一共有12个。

### forEach 方法指定数组的每项元素都执行一次传入函数，返回值为undefined.
语法：arr.forEach(fn, thisArg)

fn 标识在数组每一项上执行的函数，接收三个参数。
- value 当前正在被处理的元素的值
- index 当前正在被处理元素的索引
- array 当前数组的本身

thisArg 可选，用来当作fn函数内的this对象

forEach 将为数组中的每一项执行一次fn函数，那些已删除，新增或者从未赋值的项将被跳过（但不包括值为undefined的项）

遍历过程中，fn会被传入上述三个参数

<!-- more -->
```js
var arr =[1,2,3,4]
var obj = {name:'cc'}
arr.forEach(function(value,index,array){
	arr[index] = value * 2
	console.log(this.name)
	console.log(value)
},obj)
// cc
// 1
// cc
// 2
// cc
// 3
// cc
// 4
// obj.name执行了四次
```

同样也可以用Array.prototype.forEach.call()
```js
var o = {0:1, 1:3, 2:5, length:3};
Array.prototype.forEach.call(o,function(value, index, obj){
  console.log(value,index,obj);
  obj[index] = value * value;
},o);
```

如果不支持可以用polyfill

```js
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}
```

### every 传入的函数测试所有的元素，只要其中有一个函数返回值为false，那么该办法的结果为false；如果全部返回true，那么该办法的结果才返回true，因为every存在如下规律：

- 若需检测数组中所有存在元素是否大于10（即value > 10），那么需要在传入的函数中return 'true'返回值，同时整个方法结果为true才表示数组存在的元素满足条件 （即数组中的value 都大于10，那么就算满足条件，返回true）
- 反之 若需要检测数组中存在的元素是否有不满足的大于10的，返回 'false'

语法同forEach 相同， 

```js
var arr = [11,12,13,14,15,16]
var arr2 = [1,11,12,13,14,15]
arr.every(function(value){
	console.log(value > 10)
})
arr2.every(function(value){
	console.log(value > 10)
})

// true false
// arr2 因为数组第一个元素不满足 条件，所以返回false
```

同样也适用Array.prototype.every.call()

```js
var o = {0:10, 1:8, 2:25, length:3};
var bool = Array.prototype.every.call(o,function(value, index, obj){
  return value >= 8;
},o);
console.log(bool);
```

如果不支持，可以用ployfill

```js
if (!Array.prototype.every)
{
  Array.prototype.every = function(fun /*, thisArg */)
  {
    'use strict';

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function')
        throw new TypeError();

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t && !fun.call(thisArg, t[i], i, t))
        return false;
    }

    return true;
  };
}
```

### some 跟every相反，使用some检测数组元素时，只要有一个函数返回值为true，则该方法返回true，如果全部都返回false,则该方法才返回false，

- 若需检测数组中存在的元素是否有一个元素或多个元素大于10（即value > 10）,那么我们需要在传入的函数中 return 'true'，则some返回true,反之所有函数的返回false，则some返回false

```js
var arr = [10,1,2,3,4]
var arr2 = [1,2,3,4,5]
var arr3 = arr.some(function(value){
	return value >= 10
})
var arr4 = arr2.some(function(value){
	return value >= 10
})
console.log(arr3,arr4)

// true false
```

Array.prototype.come.call()同every一样，参照every的写法。

如果不支持的话可以用polyfill:

```js
if (!Array.prototype.some)
{
  Array.prototype.some = function(fun /*, thisArg */)
  {
    'use strict';

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function')
      throw new TypeError();

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t && fun.call(thisArg, t[i], i, t))
        return true;
    }

    return false;
  };
}
```

### filter 使用传入的函数测试所有元素，并返回所有通过测试的元素组成新的数组，他就好比一个过滤器，筛选掉不符合条件的元素。

语法：arr.filter(fn, thisArg)

```js
var arr = [10,3,20,12,13,40]
var arr2 = arr.filter(function(value){
	return value >= 10 && value <= 20
})
console.log(arr2)
// [10, 20, 12, 13]
// 满足大于等于10且小于等于20，并输出
```
Array.prototype.filter.call()写法同every一样，polyfill:

```js
if (!Array.prototype.filter)
{
  Array.prototype.filter = function(fun /* , thisArg*/)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t)
      {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t))
          res.push(val);
      }
    }

    return res;
  };
}
```


### map 遍历数组元素，使用传入函数处理每一个元素，并返回函数的返回值组成新的数组。

语法：
let new_array = arr.map(function callback(currentValue, index, array) { 
    // Return element for new_array 
}[, thisArg])

- map方法会给数组中的每个元素都按顺序调用一次callback函数，callback每次执行后返回的返回值（包括undefined）组合成新的数组，callback函数只会在有有值的索引上被调用，那些从来没被赋过值或者使用delete删除的索引则不会使用。
- callback 函数会被自动传入三个参数，数组元素，数组索引，原数组本身
- thisArg 参数有值，则每次callback函数被调用的时候，this都会指向这个thisArg参数上的这个对象，如果省略了thisArg参数，或者赋值为null或undefined，则this指向全局对象。
- map在执行的的时候不会修改原数组本身 （也可以在callback执行时改变原数组元素）
- 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。

```js
var obj = [{key:1,value:10},{key:2,value:20},{key:3,value:30}]
var obj2 = obj.map(function(value){
	var robj = {};
	robj[value.key] = value.value;
	return robj
})
console.log(obj2)

// 0:{1: 10}
// 1:{2: 20}
// 2:{3: 30}


// console.log(obj)
// 0:{key: 1, value: 10}
// 1:{key: 2, value: 20}
// 2:{key: 3, value: 30}
// 原远足未被修改
```

Array.prototype.map.cal()使用:
```js
var a = Array.prototype.map.call('hello word',function(value){
	console.log(value)
})


h
e
l
l
o

w
o
r
d
```

遍历querySelectorAll()所有集合
```js
var el = document.querySelectorAll('div')
Array.prototype.map.call(el,function(value){
	console.log(value)
})
```

返回字符串
```js
var str = '12345';
Array.prototype.map.call(str, function(x) {
  return x;
}).reverse().join(''); 

// 输出: '54321'
```

MDN上有这么描述map的话：

通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。

```js
// 下面的语句返回什么呢:
["1", "2", "3"].map(parseInt);
// 你可能觉的会是[1, 2, 3]
// 但实际的结果是 [1, NaN, NaN]

// 通常使用parseInt时,只需要传递一个参数.
// 但实际上,parseInt可以有两个参数.第二个参数是进制数.
// 可以通过语句"alert(parseInt.length)===2"来验证.
// map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 
// 元素索引, 原数组本身.
// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,
// parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.

function returnInt(element) {
  return parseInt(element, 10);
}

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// 意料之中的结果

// 也可以使用简单的箭头函数，结果同上
['1', '2', '3'].map( str => parseInt(str) ); // [1, 2, 3]

// 一个更简单的方式:
['1', '2', '3'].map(Number); // [1, 2, 3]
// 与`parseInt` 不同，下面的结果会返回浮点数或指数:
['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
```


### reduce 接收一个方法作为累加器，数组中的每个值（从左至右）开始合并，最终一个值。

语法：arr.reduce(callback, initialValue)

callback 每次执行数组中每个值的函数，包含四个参数:

- previousValue 上一次调用回调时累计的返回的值，或者是提供的初始值
- value 数组中当前被处理元素的值
- index 当前元素在数组中的索引
- array 原数组自身

initialValue 指定第一次调用fn的第一个参数，如果没有提供初始值，则使用数组的第一个元素的值，。

当callback第一次执行时：
- 如果initialValue 在调用reduce时被提供，那么第一个previousValue 将等于initialValue，此时item等于数组中的第一个值
- 如果 initialValue 未被提供，那么 previousVaule 等于数组中的第一个值，item 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。
- 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么fn不会被执行，数组的唯一值将被返回。

计算1到900的和
```js
var arr = []
for(var i=0;i<=1000;i++){
	arr.push(i)
	if(i == 900){
		var arr2 = arr.reduce(function(sum,value){
			return sum+value
		})
	}
}
console.log(arr2)
// 405450
```

把数组的[1,2,3,4,5]转换成整数的12345
```js
var num = [1,2,3,4,5].reduce(function(x,y){
	return x.toString() + y
})
console.log(num)
// 12345
```

数组去除重复
```js
var arr = [1,2,3,2,1,33,3,2,1]
var arr2 = arr.sort().reduce(function(init,current){
	if(init.length === 0 || init[init.length-1]!== current){
		init.push(current);
	}
  return init;
},[])
console.log(arr2)
// [1, 2, 3, 33]
```

```js
var array = [1, 2, 3, 4];
var s = array.reduce(function(previousValue, value, index, array){
  return previousValue * value;
},1);
console.log(s); // 24
// ES6写法更加简洁
array.reduce((p, v) => p * v); // 24
```

以上回调被执行了4次，每次的参数和返回：
|callback	|previousValue	|currentValue	|index	|array	|return |value|
|---|---|---|---|---|---|---|
|第1次	|1	|1	|1	|[1,2,3,4]	1|
|第2次	|1	|2	|2	|[1,2,3,4]	2|
|第3次	|2	|3	|3	|[1,2,3,4]	6|
|第4次	|6	|4	|4	|[1,2,3,4]	24|

Array.prototype.reduce.call()写法参照every，如果不支持reduce,可以用polyfill:

```js
if (!Array.prototype.reduce) {
  Object.defineProperty(Array.prototype, 'reduce', {
    value: function(callback /*, initialValue*/) {
      if (this === null) {
        throw new TypeError( 'Array.prototype.reduce ' + 
          'called on null or undefined' );
      }
      if (typeof callback !== 'function') {
        throw new TypeError( callback +
          ' is not a function');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0; 

      // Steps 3, 4, 5, 6, 7      
      var k = 0; 
      var value;

      if (arguments.length >= 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in o)) {
          k++; 
        }

        // 3. If len is 0 and initialValue is not present,
        //    throw a TypeError exception.
        if (k >= len) {
          throw new TypeError( 'Reduce of empty array ' +
            'with no initial value' );
        }
        value = o[k++];
      }

      // 8. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kPresent be ? HasProperty(O, Pk).
        // c. If kPresent is true, then
        //    i.  Let kValue be ? Get(O, Pk).
        //    ii. Let accumulator be ? Call(
        //          callbackfn, undefined,
        //          « accumulator, kValue, k, O »).
        if (k in o) {
          value = callback(value, o[k], k, o);
        }

        // d. Increase k by 1.      
        k++;
      }

      // 9. Return accumulator.
      return value;
    }
  });
}
```


### reduceRight 方法与reduce写法一样，与reduce不同的是，reduceRight是从右至左开始合并，最终返回一个值，与reduce的执行方向相反，其它完全一致，写法参考reduce

polyfill:
```js
if ('function' !== typeof Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function(callback /*, initialValue*/) {
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this), len = t.length >>> 0, k = len - 1, value;
    if (arguments.length >= 2) {
      value = arguments[1];
    } else {
      while (k >= 0 && !(k in t)) {
        k--;
      }
      if (k < 0) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k--];
    }
    for (; k >= 0; k--) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}
```


### entries 基于ECMAScript2015(es6)规范，返回一个数组迭代器对象，该对象包括数组中每个索引的键值对,手动循环对象的属性值可以输出相应的属性位置的值。

```js
var arr = [1,2,3,4]
var arr2 = arr.entries()
console.log(arr2.next().value)
console.log(arr2.next().value)
console.log(arr2.next().value)
console.log(arr2.next().value)
console.log(arr2.next().value)

// [0, 1]
// [1, 2]
// [2, 3]
// [3, 4]
// undefined 数组结尾在迭代就是undefined
```

也可以使用：Array.prototype.entries.call() 

```js
var o = {0:"a", 1:"b", 2:"c", length:3};
var iterator = Array.prototype.entries.call(o);
console.log(iterator.next().value); // [0, "a"]
console.log(iterator.next().value); // [1, "b"]
console.log(iterator.next().value); // [2, "c"]
```


### find 基于ECMAScript2015(es6)规范，返回数组中第一个满足条件的元素的值，如果数组为空或是稀疏数组 则返回undefined，find不会改变原来的数组。

语法：arr.find(callback[, thisArg])

- callback 执行数组的每一个值的函数，接收3个参数
- element 当前遍历到的元素
- index 当前遍历到的索引
- array 数组本身
- thisArg 可指定callback的this参数

查找满足条件的数组对象
```js
var inventory = [
    {value: 'js', name: 0},
    {value: 'css', name: 1},
    {value: 'jq', name: 2}
];

function findCherries(fruit) { 
    return fruit.value === 'css';
}

function findIndexCher(isValue){
  return isValue === 'vue'
}

console.log(inventory.find(findCherries));  // {value: "css", name: 1}
console.log(inventory.find(findIndexCher)); // undefined
```

Array.prototype.find.call()写法与上面类似，不在阐述，

polyfill:
```js
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}
```


### findIndex 基于ECMASscript2015(es6)规范，他返回数组中第一个满足条件的元素的索引，如果没有则返回-1，写法与find相同。

```js
var inventory = [
    {value: 'js', name: 0},
    {value: 'css', name: 1},
    {value: 'jq', name: 2}
];

function findCherries(fruit) { 
    return fruit.value === 'css';
}

function findIndexCher(isValue){
  return isValue === 'vue'
}

console.log(inventory.find(findCherries));  // 1
console.log(inventory.find(findIndexCher)); // -1
```

Array.prototype.findIndex.call()写法与上面类似，不在阐述，


polyfil:
```js
if (!Array.prototype.findIndex) {
  Object.defineProperty(Array.prototype, 'findIndex', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return k.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return -1.
      return -1;
    }
  });
}
```


### keys 基于ECMAScript2015(es6)规范，返回一个数组索引的迭代器

```js
var arr = ['js','css','jq']
var iterator = arr.keys()
console.log(iterator.next()) // {value: 0, done: false}
console.log(iterator.next()) // {value: 1, done: false}
console.log(iterator.next()) // {value: 2, done: false}
console.log(iterator.next()) // {value: undefined, done: true}
```

在稀疏数组中使用keys也会 包含那些没有值的对应索引，如下：

```js
var array = ["abc", , "xyz"];
var sparseKeys = Object.keys(array);
var denseKeys = [...array.keys()];
console.log(sparseKeys); // ["0", "2"]
console.log(denseKeys);  // [0, 1, 2]
```

用keys快速生成0到10的新数组
```js
[...Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Array.prototype.keys.call()写法与上面类似，不在阐述，


### values  基于ECMAScript2015(es6)规范，返回一个数组迭代器对象，该对象包含数组中每个索引的值。用法与entries相同。

```js
var array = ["abc", "xyz"];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz
```


### Symbol.iterator 该方法基于ECMAScript 2015（ES6）规范，同 values 方法功能相同。

```js
var array = ["abc", "xyz"];
var iterator = array[Symbol.iterator]();
console.log(iterator.next().value); // abc
console.log(iterator.next().value); // xyz
```


参考资料1：http://louiszhai.github.io/2017/04/28/array
参考资料2：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array